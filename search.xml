<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023 NepnepCTF RSA_random</title>
      <link href="/2023/10/10/2023-NepnepCTF-RSA-random/"/>
      <url>/2023/10/10/2023-NepnepCTF-RSA-random/</url>
      
        <content type="html"><![CDATA[<h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><pre><code class="Python">from gmpy2 import next_prime, invert as inverse_modfrom Crypto.Cipher import PKCS1_v1_5from Crypto.PublicKey import RSAfrom random import getrandbitsfrom math import lcmfrom sys import exitglobal_bits = 1024BANNER = rb&quot;&quot;&quot;.--------.--------.--------.--------.--------.--------.--------.--------.--------.--------.--------.| N.--.  | E.--.  | P.--.  | C.--.  | T.--.  | F.--.  | H.--.  | A.--.  | P.--.  | P.--.  | Y.--.  ||  :/\:  |  (\/)  |  :():  |  :/\:  |  :/\:  |  :/\:  |  (\/)  |  :():  |  :/\:  |  :/\:  |  (\/)  ||  :\/:  |  :\/:  |  ()()  |  (__)  |  :\/:  |  (__)  |  :\/:  |  ()()  |  :\/:  |  :\/:  |  :\/:  ||  &#39;--&#39;n |  &#39;--&#39;e |  &#39;--&#39;p |  &#39;--&#39;c | &#39;--&#39;t  |  &#39;--&#39;f |  &#39;--&#39;h |  &#39;--&#39;a |  &#39;--&#39;p |  &#39;--&#39;p |  &#39;--&#39;y |`--------`--------`--------`--------&#39;--------`--------`--------`--------`--------`--------`--------`&quot;&quot;&quot;def generate_prime(bits: int):    p = (getrandbits(bits - 32) &lt;&lt; 32)    return next_prime(p)def generate_private_key(bits: int):    p, q = generate_prime(bits), generate_prime(bits)    n, phi = p * q, lcm(p-1, q-1)    d = inverse_mod(0x10001, phi)    privateKey = RSA.construct((int(n), int(0x10001), int(d), int(p), int(q)))    return privateKey, p &gt; qif __name__ == &quot;__main__&quot;:    print(BANNER.decode())    print(&quot;Welcome to the world of random RSA.&quot;)    print(&quot;Please make your choice.&quot;)    for _ in range(8):        choice = input()        if choice == &#39;1&#39;:            p, q = generate_prime(global_bits), generate_prime(global_bits)            N = p*q            d = generate_prime(global_bits-32)            e = inverse_mod(d, (p * p - 1) * (q * q - 1))            print(f&quot;&#123;int(N)&#125;&quot;)            print(f&quot;&#123;int(e)&#125;&quot;)        elif choice == &#39;2&#39;:            privateKey, signal = generate_private_key(global_bits)            Cipher = PKCS1_v1_5.new(privateKey)            c = (Cipher.encrypt(flag.encode()))            print(c)            exit()        else:            exit()</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="MT19937-PRNG预测"><a href="#MT19937-PRNG预测" class="headerlink" title="MT19937 PRNG预测"></a>MT19937 PRNG预测</h3><p>观察choice，发现choice&#x3D;1和choice&#x3D;2好像并没有直接的关系，但是都用到了getrandbits函数，联想到MT19937 PRNG预测</p><p><a href="https://github.com/kmyk/mersenne-twister-predictor">参考</a></p><pre><code class="Python">import randomfrom mt19937predictor import MT19937Predictorpredictor = MT19937Predictor()for _ in range(624):    x = random.getrandbits(32)    predictor.setrandbits(x, 32)assert random.getrandbits(32) == predictor.getrandbits(32)</code></pre><p>题目一共有8次交互机会，当choice&#x3D;1，pq都是<code>getrandbits(1024-32)</code>，d是<code>getrandbits(1024-32-32)</code>，所以前7轮可以获得<code>(992*2+960)*7=20608</code>bits，满足MT19937所需要的<code>624*32=19968</code>bits</p><p>然后根据每一轮的N、e用连分数恢复p、q、d，就可以预测了</p><h3 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a>连分数</h3><p>比赛的时候没找到题目对应的论文，只找到了<a href="https://www.anquanke.com/post/id/221400#h3-4">X-NUCA weird</a>这个比较相似的，但是不会构造成题目<code>e=inverse_mod(d, (p*p-1)*(q*q-1))</code>的形式，论文提到这种形式可以找<code>e / (N^2-9/4*N+1)</code>的连分数</p><p><strong>注意</strong>：题目没有输出每一轮p和q的顺序，所以需要爆破互换pq的，复现为了方便验证，手动加上一个signal值</p><h2 id="本地复现"><a href="#本地复现" class="headerlink" title="本地复现"></a>本地复现</h2><pre><code class="Python">from Crypto.Cipher import PKCS1_v1_5from Crypto.PublicKey import RSAfrom random import getrandbitsfrom sys import exitfrom mt19937predictor import MT19937Predictorflag = &quot;NepCTF&#123;c4e4356067fb3bedc53dde7af59beb1c&#125;&quot;global_bits = 1024def generate_prime(bits: int):    p = (getrandbits(bits - 32) &lt;&lt; 32)    return next_prime(p)def generate_private_key(bits: int):    p, q = generate_prime(bits), generate_prime(bits)    n, phi = p * q, lcm(p-1, q-1)    d = inverse_mod(0x10001, phi)    privateKey = RSA.construct((int(n), int(0x10001), int(d), int(p), int(q)))    return privateKeyNN = []ee = []signal = []for _ in range(7):    p, q = generate_prime(global_bits), generate_prime(global_bits)    if p &gt; q:        signal.append(1)    else:        signal.append(0)    N = p*q    d = generate_prime(global_bits-32)    e = inverse_mod(d, (p * p - 1) * (q * q - 1))    NN.append(N)    ee.append(e)privateKey = generate_private_key(global_bits)Cipher = PKCS1_v1_5.new(privateKey)c = Cipher.encrypt(flag.encode())# print(c)# 连分数解pqddef attack(N, e):    convergents = continued_fraction(e/(N^2-9/4*N+1)).convergents()    for c in convergents:        k = c.numerator()        d = c.denominator()        if pow(pow(2, e, N), d, N) == 2:            phi = (e * d - 1) // k  #(p^2-1)*(q^2-1) = n^2+1-p^2-q^2            p_a_q = sqrt(N^2 + 1 - phi + 2*N)            p_s_q = sqrt(N^2 + 1 - phi - 2*N)            p = (p_a_q - p_s_q)//2            assert N % p == 0            q = N//p            d = inverse_mod(e, (p * p - 1) * (q * q - 1))            return int(p), int(q), int(d)predictor = MT19937Predictor()for i in range(7):    # print(i)    p, q, d = attack(int(NN[i]), int(ee[i]))    # 根据signal调整pq顺序    if signal[i] == 0:        if p &gt; q:            p, q = q, p    else:        if p &lt; q:            p, q = q, p        predictor.setrandbits(p&gt;&gt;32, 992)    predictor.setrandbits(q&gt;&gt;32, 992)    predictor.setrandbits(d&gt;&gt;32, 960)p = next_prime(predictor.getrandbits(992) &lt;&lt; 32)q = next_prime(predictor.getrandbits(992) &lt;&lt; 32)n, phi = p * q, lcm(p-1, q-1)d = inverse_mod(0x10001, phi)privateKey = RSA.construct((int(n), int(0x10001), int(d), int(p), int(q)))Cipher = PKCS1_v1_5.new(privateKey)flag = Cipher.decrypt(c,&#39;\x00&#39;)print(flag)# b&#39;NepCTF&#123;c4e4356067fb3bedc53dde7af59beb1c&#125;&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题目 </category>
          
          <category> 2023 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
            <tag> 随机数预测 </tag>
            
            <tag> 连分数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
